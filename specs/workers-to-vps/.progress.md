# Progress: workers-to-vps

## Goal
We need to move off cloudflare workers locked architecture as we are moving to our free tier oracle server

## Status
Phase 2 IN PROGRESS - Refactoring

## Completed Tasks
- [x] 1.1 Set up Redis client module - 2780309
- [x] 1.2 Implement circuit breaker with Redis - 559893c
- [x] 1.3 Implement cron lock with Redis - fec39d8
- [x] 1.4 Set up BullMQ queue infrastructure - 697308b
- [x] 1.5 Implement queue worker - 17cac30
- [x] 1.6 Implement node-cron scheduler - 12d91a8
- [x] 1.7 Create application entry point - 400b7e0
- [x] 1.8 Update health endpoint for Redis - c64f0b6
- [x] 1.9 POC Checkpoint - e83268f
- [x] 2.1 Remove Cloudflare-specific files - 5296b4a
- [x] 2.2 Update cron API route - 4cef1bb
- [x] 2.3 Update package.json dependencies - 8d28ceb
- [x] 2.4 Add error handling and logging - a1b7d22
- [x] 2.5 Add graceful shutdown - 4bd2745

## Current Task
Awaiting next task

## Next
Task 3.1: Unit tests for circuit breaker

## Timeline
- Started: 2026-01-15
- Artifacts generated: 2026-01-15

## Learnings

### Codebase Exploration (Quick Mode)
- Current architecture heavily uses Cloudflare-specific primitives that need replacement
- `worker.ts` contains Durable Object implementations (~750 lines) for CircuitBreakerDO and CronLockDO
- Queue processing logic is split between `app/api/cron/route.ts` (enqueue) and `app/api/queue/process-section/route.ts` (process)
- Health endpoint at `app/api/monitoring/health/route.ts` checks Durable Object status
- Existing scraper service already runs on Oracle Cloud with Puppeteer
- Email sending via Resend batch API is independent of Cloudflare
- Supabase database queries are platform-agnostic

### Key Patterns Discovered
- Atomic notification deduplication via `tryRecordNotification()` PostgreSQL function
- Circuit breaker with 10 failure threshold, 2-minute recovery timeout, 3 success threshold
- Cron lock with 25-minute auto-expiry
- Staggered checking (even/odd section numbers at :00/:30)

### Cron Lock Implementation
- Used Redis SET NX PX for atomic lock acquisition with TTL baked in
- Lua script for atomic conditional release (prevents releasing locks we don't hold)
- Separate metadata key stores lockAcquiredAt timestamp for status queries
- Both lock key and metadata key share the same TTL for consistent expiry

### Architecture Decisions Made
- **BullMQ over pg-boss**: Better performance, feature parity with Cloudflare Queues
- **Upstash Redis over VPS Redis**: Free tier sufficient, no memory impact on 1GB VPS
- **PM2 over Docker**: Lower memory overhead for constrained VPS
- **Caddy over Nginx**: Automatic HTTPS, simpler configuration

### Scope Decisions
- Scraper service unchanged (already on Oracle Cloud)
- Database unchanged (Supabase PostgreSQL)
- Email service unchanged (Resend)
- Only infrastructure layer being migrated

### Assumptions Made
- Oracle Cloud VPS has 1GB RAM, 1 OCPU (ARM64)
- Upstash Redis free tier (10K commands/day) sufficient for 10K users
- DNS switch approach acceptable for zero-downtime migration
- Current 100 concurrent workers can be reduced to 4 on VPS with acceptable latency

### BullMQ Integration Notes
- BullMQ bundles its own ioredis (v5.9.1), cannot share ioredis instance from lib/redis/client.ts due to TypeScript type conflicts
- Must parse REDIS_URL and pass connection options to BullMQ Queue/Worker instead
- BullMQ requires `maxRetriesPerRequest: null` for proper blocking operations
- Queue singletons use lazy initialization to avoid connection on import
- Job deduplication via jobId: `${term}-${classNbr}` prevents duplicate processing

### node-cron v4.x Notes
- node-cron 4.x has different API than @types/node-cron 3.x suggests
- TaskOptions only has: timezone, name, noOverlap, maxExecutions, maxRandomDelay
- No `scheduled` or `recoverMissedExecutions` options in v4.x
- Tasks need explicit .start() call after creation
- Callback receives TaskContext, not (Date | "manual" | "init")

### Server Entry Point Notes
- Using Next.js custom server approach (not standalone output mode) for easier integration
- Custom server allows running cron scheduler and queue workers in the same process
- Startup sequence: Redis -> Next.js -> HTTP Server -> Cron -> Worker
- Shutdown sequence (reverse): HTTP -> Cron -> Worker -> Queues -> Redis
- Graceful shutdown waits for current queue jobs to complete before closing
- Uses flag to prevent double shutdown on repeated SIGTERM/SIGINT signals

### Health Endpoint Migration Notes
- Replaced Cloudflare Durable Objects with Redis-based checks for circuit breaker and cron lock
- Added new checks: Redis connection status, BullMQ queue stats, scheduler status
- Added REDIS_URL to required environment variables list
- Response structure maintained for compatibility, only added `type: 'redis'` or `type: 'bullmq'` to distinguish from previous Durable Object implementation
- Scheduler status check is synchronous (no Redis call needed)

### POC Checkpoint Verification
- All 11 new files created and verified
- All module imports work without runtime errors
- Key exports available: getRedisClient, getCircuitBreaker, acquireLock, startWorker, startScheduler, etc.
- TypeScript compiles without errors in POC files (pre-existing test file has unrelated issue)
- Build passes: `bun run build` completes successfully
- Lint passes: `bun run lint` shows no issues
- Added POC verification script at scripts/poc-verify.ts for future validation
- Full end-to-end testing requires running Redis instance (Upstash or local)
- Manual testing documented: server startup, health endpoint, cron trigger, queue processing, graceful shutdown

### Cloudflare Cleanup Notes (Task 2.1)
- Deleted 5 Cloudflare-specific files: worker.ts (751 lines), wrangler.jsonc, lib/cloudflare-env.d.ts (10K lines generated types), lib/types/queue.ts, app/api/queue/process-section/route.ts
- Added legacy type stubs to lib/queue/types.ts for backward compatibility during migration
- The cron route (app/api/cron/route.ts) still uses @opennextjs/cloudflare import and Cloudflare Durable Object types - will be refactored in task 2.2
- Stub types include: ClassCheckMessage (snake_case legacy), Env, DurableObjectNamespace, CloudflareQueue
- Empty directories removed: lib/types/, app/api/queue/process-section/, app/api/queue/

### Cron Route Refactoring (Task 2.2)
- Rewrote app/api/cron/route.ts as a thin wrapper calling runClassCheckCron() from lib/cron/class-check.ts
- Removed all Cloudflare-specific imports: @opennextjs/cloudflare, getCloudflareContext(), Durable Object interactions
- Kept authentication check (CRON_SECRET Bearer token)
- Route now returns HTTP 409 for lock conflicts, 500 for other errors, 200 for success
- Response format uses snake_case (sections_enqueued, stagger_group, duration) for backward compatibility
- Cleaned up lib/queue/types.ts: removed all deprecated legacy stubs (ClassCheckMessage, Env, DurableObjectNamespace, DurableObjectStub, CloudflareQueue)

### Dependency Cleanup (Task 2.3)
- Removed Cloudflare dependencies from package.json: cloudflare, @opennextjs/cloudflare, wrangler
- Removed Cloudflare-specific scripts: preview, deploy, cf-typegen
- Added start:prod script for VPS production: `bun server.ts`
- Also removed open-next.config.ts (missed in task 2.1, was importing @opennextjs/cloudflare)
- Deleted stale package-lock.json (using bun.lock)
- bullmq, ioredis, node-cron, @types/node-cron were already present from Phase 1 tasks

### Error Handling and Logging (Task 2.4)
- Added try/catch blocks to all Redis operations in circuit-breaker.ts, cron-lock.ts, client.ts
- Added try/catch to all BullMQ operations in queues.ts and worker.ts
- Added structured logging with [Module] prefix for all components:
  - [Redis] for Redis client operations
  - [CircuitBreaker] for circuit breaker state changes
  - [CronLock] for distributed lock operations
  - [Queue] for queue operations
  - [Worker] for job processing
  - [Cron] for cron job execution
  - [Scheduler] for cron scheduler lifecycle
- Errors include context (job ID, section number, lock holder, etc.)
- Timestamps included in cron/scheduler logs for debugging timing issues
- Fail-open strategy for circuit breaker (allow requests if Redis fails)
- Graceful degradation: health checks return zeros on error, don't fail entirely
- Shutdown functions don't re-throw errors to allow cleanup to continue

### Graceful Shutdown Enhancement (Task 2.5)
- Added 30-second forced shutdown timeout to prevent hanging if any service fails to close
- Timer.unref() ensures the timeout timer doesn't block natural process exit
- Each shutdown step now logs completion (Step X/5: ... + completion message)
- Timer is cleared on successful or error completion to avoid double-exit
- Shutdown order: HTTP server -> Cron scheduler -> Queue worker -> Queue connections -> Redis
